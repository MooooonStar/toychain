# 程序员眼中的区块链

## 前言
最近区块链热度又起来了，但炒概念的居多，落地的应用很少。网络上论述区块链的文章也不少，但充斥的大量的生僻的名词，

看完之后仍是不明所以。

## 区块链
区块链，英文为blockchain，其实是两个词，block和chain，分别是块和链的意思，合起来就叫区块链。我个人对于区块链

的定义是： 区块链是一个个区块构成的链表，区块是一些交易的集合。

### 区块
先来看下什么是区块，以 ```0000000000000bae09a7a393a8acded75aa67e46cb81f7acaa5ad94f9eacd103``` 这个块为例，

其基本结构如下。
```json 
{
    "ver":1,
    "prev_block":"00000000000007d0f98d9edca880a6c124e25095712df8952e0439ac7409738a",
    "mrkl_root":"935aa0ed2e29a4b81e0c995c39e06995ecce7ddbebb26ed32d550a72e8200bf5",
    "time":1322131230,
    "bits":437129626,
    "nonce":2964215930,
    "tx":[--Array of Transactions--]
}
```
 其中各字段的含义：
 - ver, 版本
 - prev_block, 上一个块的哈希。学过C的应该知道，这表明区块链的数据结构是链表，并且是个前向列表。从任意一个节点的位置

可以一直往前遍历直到表头，这也是区块链号称可以追根溯源的原因。
 - mrkl_root, 默克尔树根，为交易列表的哈希。
 - time, 区块生成的时间，unix时间戳
 - bits, 难度
 - nonce, 随机数，和难度一起定义了区块链链表增长的规则，即设置了一个难题，只有答对了的块才能连接到链上去。
 - tx, 交易列表

所以，我们可以这么理解一个区块： 区块里包含了一些交易数据和前一个区块的哈希值，并且为后来的块留下了一个谜题。

注: mrkl_root, bits, nonce 字段的详细介绍见后文。

### 交易

再来看下什么是交易，以`b6f6991d03df0e2e04dafffcd6bc418aac66049e2cd74b80f14ac86db1e3f0da`这笔交易为例

```json 
{
  "inputs": [
    {
      "txid": ,
      "vout": 2,
      "scriptSig": "48304502210098a2851420e4daba656fd79cb60cb565bd7218b6b117fda9a512ffbf17f8f178022005c61f31fef3ce3f906eb672e05b65f506045a65a80431b5eaf28e0999266993014104f0f86fa57c424deb160d0fc7693f13fce5ed6542c29483c51953e4fa87ebf247487ed79b1ddcf3de66b182217fcaf3fcef3fcb44737eb93b1fcb8927ebecea26"
    }
  ],
  "out": [
    {
      "value": "98000000",
      "scriptPubKey": "76a91429d6a3540acfa0a950bef2bfdc75cd51c24390fd88ac"
    },
    {
      "value": "2000000",
      "scriptPubKey": "76a91417b5038a413f5c5ee288caa64cfab35a0c01914e88ac"
    }
  ]
}
```

看到这样的结构，肯定是一脸懵逼的，因为常规的交易就是Alice向Bob转账了200，结构应该是这样的

```json
{
  "from": "Alice",
  "to": "Bob",
  "amount": 200
}

```
而实际的交易结构里完全没有类似的字段。原因就在于BTC采用了UTXO(unspent transaction outputs)模型，

称为"未花费的交易输出"。

现实生活中采用的是账户模型，比如Alice、Bob账户上起初余额分别是500,100, Alice向

Bob转账200，即在数据库里起个事务,把Alice账户扣除200,同时把Bob账户增加200，一笔交易就算完成了。而了解

BTC中的交易，得先理解交易输入和交易输出。

### 交易输出

交易输出包含两部分:

- value, 数量，单位聪(satoshis), 1BTC = 10^8 satoshis
- scriptPubKey, 锁定脚本。以`76a91429d6a3540acfa0a950bef2bfdc75cd51c24390fd88ac`为例，它实际上是
  
``` OP_DUP OP_HASH160 29d6a3540acfa0a950bef2bfdc75cd51c24390fd OP_EQUALVERIFY OP_CHECKSIG```

其中十六进制部分就是个地址 `14pDqB95GWLWCjFxM4t96H2kXH7QMKSsgG`(当然这里涉及到公钥和BTC地址的转换关系，留到后文介绍)，

剩余的部分是BTC里定义的一些运算，简单得理解为加减乘除就好了。

简而言之，交易输出就是在某个地址上放一定数量的BTC， 需要解锁其中包含的脚本才能使用。

### 交易输入

交易输入包含三部分:
    
- txid: 输入引用的交易id.
- vout: 引用交易的交易输出的索引。如一笔交易产生了5个交易输入，这里vout可以是0,1,2,3,4.
- scriptSig: 解锁脚本，包含一个签名和公钥，和锁定脚本拼起来是如下形式
  ``` <Signature> <PublicKey> | DUP HASH160 <PubKeyHash> EQUALVERIFY CHECKSIG

BTC里面的支付称为对公钥哈希的付款(P2PKH, Pay-to-Public-Key-Hash),原因就在于此, 交易A的输出里会放一个公钥

的哈希，使用者需要在交易B的输入里用私钥对这笔交易B签名，同时提供要转出的地址。上面拼起来的脚本做了两件事，

一是先对输入的公钥进行哈希，看是否和输出的一致，相当于先验证你要转账的人有没有填错，二是用公钥验证签名对不对，

即验证你是否拥有使用权。

因而，交易即在之前的交易中找到自己拥有的交易输出，签名使用并将所有权转让给别人。所以BTC里是没有"余额"这个东西的，

钱包里所展示的余额，其实是遍历了所有未花费的交易输出，然后求和后的结果。

### 创币交易

前面的交易输入和交易输出有个鸡生蛋还是蛋生鸡的问题，没有输入显然就没有输出，而输出又需要引用输入，解决方案就是

每个区块的第一个是个创币交易(coinbase)，只有输出没有输入，也就是不需要解锁脚本，该字段被coinbase数据代替。

如创世块中，中本聪就填入了"The Times 03/Jan/ 2009 Chancellor on brink of second bailout for banks".

创币交易的数量是被给定的规则限定的，经常提到的BTC产量每4年减半，就是指创币交易的数量，而输出不用说，肯定会填上矿工

自己的地址啊。


